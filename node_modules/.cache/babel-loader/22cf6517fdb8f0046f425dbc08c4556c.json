{"ast":null,"code":"'use strict';\n\nmodule.exports = decode;\nvar keys, values, lengths, dim, e;\nvar geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeometryCollection'];\n\nfunction decode(pbf) {\n  dim = 2;\n  e = Math.pow(10, 6);\n  lengths = null;\n  keys = [];\n  values = [];\n  var obj = pbf.readFields(readDataField, {});\n  keys = null;\n  return obj;\n}\n\nfunction readDataField(tag, obj, pbf) {\n  if (tag === 1) keys.push(pbf.readString());else if (tag === 2) dim = pbf.readVarint();else if (tag === 3) e = Math.pow(10, pbf.readVarint());else if (tag === 4) readFeatureCollection(pbf, obj);else if (tag === 5) readFeature(pbf, obj);else if (tag === 6) readGeometry(pbf, obj);\n}\n\nfunction readFeatureCollection(pbf, obj) {\n  obj.type = 'FeatureCollection';\n  obj.features = [];\n  return pbf.readMessage(readFeatureCollectionField, obj);\n}\n\nfunction readFeature(pbf, feature) {\n  feature.type = 'Feature';\n  var f = pbf.readMessage(readFeatureField, feature);\n  if (!('geometry' in f)) f.geometry = null;\n  return f;\n}\n\nfunction readGeometry(pbf, geom) {\n  geom.type = 'Point';\n  return pbf.readMessage(readGeometryField, geom);\n}\n\nfunction readFeatureCollectionField(tag, obj, pbf) {\n  if (tag === 1) obj.features.push(readFeature(pbf, {}));else if (tag === 13) values.push(readValue(pbf));else if (tag === 15) readProps(pbf, obj);\n}\n\nfunction readFeatureField(tag, feature, pbf) {\n  if (tag === 1) feature.geometry = readGeometry(pbf, {});else if (tag === 11) feature.id = pbf.readString();else if (tag === 12) feature.id = pbf.readSVarint();else if (tag === 13) values.push(readValue(pbf));else if (tag === 14) feature.properties = readProps(pbf, {});else if (tag === 15) readProps(pbf, feature);\n}\n\nfunction readGeometryField(tag, geom, pbf) {\n  if (tag === 1) geom.type = geometryTypes[pbf.readVarint()];else if (tag === 2) lengths = pbf.readPackedVarint();else if (tag === 3) readCoords(geom, pbf, geom.type);else if (tag === 4) {\n    geom.geometries = geom.geometries || [];\n    geom.geometries.push(readGeometry(pbf, {}));\n  } else if (tag === 13) values.push(readValue(pbf));else if (tag === 15) readProps(pbf, geom);\n}\n\nfunction readCoords(geom, pbf, type) {\n  if (type === 'Point') geom.coordinates = readPoint(pbf);else if (type === 'MultiPoint') geom.coordinates = readLine(pbf, true);else if (type === 'LineString') geom.coordinates = readLine(pbf);else if (type === 'MultiLineString') geom.coordinates = readMultiLine(pbf);else if (type === 'Polygon') geom.coordinates = readMultiLine(pbf, true);else if (type === 'MultiPolygon') geom.coordinates = readMultiPolygon(pbf);\n}\n\nfunction readValue(pbf) {\n  var end = pbf.readVarint() + pbf.pos,\n      value = null;\n\n  while (pbf.pos < end) {\n    var val = pbf.readVarint(),\n        tag = val >> 3;\n    if (tag === 1) value = pbf.readString();else if (tag === 2) value = pbf.readDouble();else if (tag === 3) value = pbf.readVarint();else if (tag === 4) value = -pbf.readVarint();else if (tag === 5) value = pbf.readBoolean();else if (tag === 6) value = JSON.parse(pbf.readString());\n  }\n\n  return value;\n}\n\nfunction readProps(pbf, props) {\n  var end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) props[keys[pbf.readVarint()]] = values[pbf.readVarint()];\n\n  values = [];\n  return props;\n}\n\nfunction readPoint(pbf) {\n  var end = pbf.readVarint() + pbf.pos,\n      coords = [];\n\n  while (pbf.pos < end) coords.push(pbf.readSVarint() / e);\n\n  return coords;\n}\n\nfunction readLinePart(pbf, end, len, closed) {\n  var i = 0,\n      coords = [],\n      p,\n      d;\n  var prevP = [];\n\n  for (d = 0; d < dim; d++) prevP[d] = 0;\n\n  while (len ? i < len : pbf.pos < end) {\n    p = [];\n\n    for (d = 0; d < dim; d++) {\n      prevP[d] += pbf.readSVarint();\n      p[d] = prevP[d] / e;\n    }\n\n    coords.push(p);\n    i++;\n  }\n\n  if (closed) coords.push(coords[0]);\n  return coords;\n}\n\nfunction readLine(pbf) {\n  return readLinePart(pbf, pbf.readVarint() + pbf.pos);\n}\n\nfunction readMultiLine(pbf, closed) {\n  var end = pbf.readVarint() + pbf.pos;\n  if (!lengths) return [readLinePart(pbf, end, null, closed)];\n  var coords = [];\n\n  for (var i = 0; i < lengths.length; i++) coords.push(readLinePart(pbf, end, lengths[i], closed));\n\n  lengths = null;\n  return coords;\n}\n\nfunction readMultiPolygon(pbf) {\n  var end = pbf.readVarint() + pbf.pos;\n  if (!lengths) return [[readLinePart(pbf, end, null, true)]];\n  var coords = [];\n  var j = 1;\n\n  for (var i = 0; i < lengths[0]; i++) {\n    var rings = [];\n\n    for (var k = 0; k < lengths[j]; k++) rings.push(readLinePart(pbf, end, lengths[j + 1 + k], true));\n\n    j += lengths[j] + 1;\n    coords.push(rings);\n  }\n\n  lengths = null;\n  return coords;\n}","map":null,"metadata":{},"sourceType":"script"}