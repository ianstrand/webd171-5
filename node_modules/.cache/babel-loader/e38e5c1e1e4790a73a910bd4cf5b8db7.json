{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar geobuf = require('geobuf');\n\nvar inside = require('@turf/boolean-point-in-polygon').default;\n\nvar Pbf = require('pbf');\n\nvar point = require('@turf/helpers').point;\n\nvar tzData = require('../data/index.json');\n\nconst {\n  getTimezoneAtSea,\n  oceanZones\n} = require('./oceanUtils');\n\nlet featureCache;\n/**\n * Set caching behavior.\n */\n\nfunction cacheLevel(options) {\n  if (options && options.store && typeof options.store.get === 'function' && typeof options.store.set === 'function') {\n    featureCache = options.store;\n  } else {\n    featureCache = new Map();\n  }\n\n  if (options && options.preload) {\n    preCache();\n  }\n}\n\ncacheLevel();\n/**\n * A function that will load all features into an unexpiring cache\n */\n\nfunction preCache() {\n  // shoutout to github user @magwo for an initial version of this recursive function\n  var preloadFeaturesRecursive = function (curTzData, quadPos) {\n    if (curTzData === 'f') {\n      var geoJson = loadFeatures(quadPos);\n      featureCache.set(quadPos, geoJson);\n    } else if (typeof curTzData === 'object') {\n      Object.getOwnPropertyNames(curTzData).forEach(function (value) {\n        preloadFeaturesRecursive(curTzData[value], quadPos + value);\n      });\n    }\n  };\n\n  preloadFeaturesRecursive(tzData.lookup, '');\n}\n\nvar loadFeatures = function (quadPos) {\n  // exact boundaries saved in file\n  // parse geojson for exact boundaries\n  var filepath = quadPos.split('').join('/');\n  var data = new Pbf(fs.readFileSync(path.join(__dirname, '/../data/', filepath, '/geo.buf')));\n  var geoJson = geobuf.decode(data);\n  return geoJson;\n};\n\nvar getTimezone = function (originalLat, originalLon) {\n  let lat = parseFloat(originalLat);\n  let lon = parseFloat(originalLon);\n  var err; // validate latitude\n\n  if (isNaN(lat) || lat > 90 || lat < -90) {\n    err = new Error('Invalid latitude: ' + lat);\n    throw err;\n  } // validate longitude\n\n\n  if (isNaN(lon) || lon > 180 || lon < -180) {\n    err = new Error('Invalid longitude: ' + lon);\n    throw err;\n  } // North Pole should return all ocean zones\n\n\n  if (lat === 90) {\n    return oceanZones.map(zone => zone.tzid);\n  } // fix edges of the world\n\n\n  if (lat >= 89.9999) {\n    lat = 89.9999;\n  } else if (lat <= -89.9999) {\n    lat = -89.9999;\n  }\n\n  if (lon >= 179.9999) {\n    lon = 179.9999;\n  } else if (lon <= -179.9999) {\n    lon = -179.9999;\n  }\n\n  var pt = point([lon, lat]);\n  var quadData = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0\n  };\n  var quadPos = '';\n  var curTzData = tzData.lookup;\n\n  while (true) {\n    // calculate next quadtree position\n    var nextQuad;\n\n    if (lat >= quadData.midLat && lon >= quadData.midLon) {\n      nextQuad = 'a';\n      quadData.bottom = quadData.midLat;\n      quadData.left = quadData.midLon;\n    } else if (lat >= quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'b';\n      quadData.bottom = quadData.midLat;\n      quadData.right = quadData.midLon;\n    } else if (lat < quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'c';\n      quadData.top = quadData.midLat;\n      quadData.right = quadData.midLon;\n    } else {\n      nextQuad = 'd';\n      quadData.top = quadData.midLat;\n      quadData.left = quadData.midLon;\n    } // console.log(nextQuad)\n\n\n    curTzData = curTzData[nextQuad]; // console.log()\n\n    quadPos += nextQuad; // analyze result of current depth\n\n    if (!curTzData) {\n      // no timezone in this quad, therefore must be timezone at sea\n      return getTimezoneAtSea(originalLon);\n    } else if (curTzData === 'f') {\n      // get exact boundaries\n      var geoJson = featureCache.get(quadPos);\n\n      if (!geoJson) {\n        geoJson = loadFeatures(quadPos);\n        featureCache.set(quadPos, geoJson);\n      }\n\n      var timezonesContainingPoint = [];\n\n      for (var i = 0; i < geoJson.features.length; i++) {\n        if (inside(pt, geoJson.features[i])) {\n          timezonesContainingPoint.push(geoJson.features[i].properties.tzid);\n        }\n      } // if at least one timezone contained the point, return those timezones,\n      // otherwise must be timezone at sea\n\n\n      return timezonesContainingPoint.length > 0 ? timezonesContainingPoint : getTimezoneAtSea(originalLon);\n    } else if (curTzData.length > 0) {\n      // exact match found\n      return curTzData.map(idx => tzData.timezones[idx]);\n    } else if (typeof curTzData !== 'object') {\n      // not another nested quad index, throw error\n      err = new Error('Unexpected data type');\n      throw err;\n    } // calculate next quadtree depth data\n\n\n    quadData.midLat = (quadData.top + quadData.bottom) / 2;\n    quadData.midLon = (quadData.left + quadData.right) / 2;\n  }\n};\n\nmodule.exports = getTimezone;\nmodule.exports.setCache = cacheLevel; // for backwards compatibility\n\nmodule.exports.preCache = function () {\n  cacheLevel({\n    preload: true\n  });\n};","map":null,"metadata":{},"sourceType":"script"}